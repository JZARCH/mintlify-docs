---
title: 'Overview'
description: 'Webhook integration guide and delivery model'
---

## Webhook integration guide

The Zil Money Webhook Integration Guide provides comprehensive documentation for all webhook events generated by the Zil Money platform.

Each webhook event is delivered as an HTTP POST request to your registered endpoint whenever a corresponding action occurs within the system, ensuring your application receives timely and reliable event data directly from Zil Money.

## Overview

Zil Money webhooks enable your application to receive real-time notifications when platform events occur, including ACH transfers, check mailings, wallet-associated transactions, eCheck payments, GPBF payments, and more.

By integrating webhooks, you can automate business workflows, synchronize transaction data, trigger internal processes, and maintain accurate, up-to-date records within your system.

## Setup

To receive webhooks:

1. Navigate to **Developer Panel -> Webhooks** in your Zil Money dashboard.
2. Register your endpoint URL (`webhook_url`).
3. Optionally set a **Webhook Secret** (`webhook_secret`) to enable signature verification.
4. Select the specific event types you want to subscribe to.

## Payload Envelope

All OCW (OnlineCheckWriter/Zil Money) webhook events share a common envelope structure:

```json
{
  "event": {
    "type": "event.type.name",
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "createdAt": "2024-01-15T10:30:00.000000Z",
    "data": {}
  }
}
```

| Field | Type | Description |
| --- | --- | --- |
| `event.type` | string | The event type identifier (e.g., `manual-ach.initiated`) |
| `event.id` | string (UUID) | Unique identifier for this webhook delivery â€” use for idempotency |
| `event.createdAt` | ISO 8601 datetime | Timestamp when the event was created |
| `event.data` | object | Event-specific payload (see each event for schema) |

## Security & Signature Verification

When a `webhook_secret` is configured, every request is signed using **HMAC-SHA256**.

### Request Headers

| Header | Description |
| --- | --- |
| `Signature` | HMAC-SHA256 of the raw JSON request body, signed with your `webhook_secret` |
| `Content-Type` | `application/json` |

### Signature Algorithm

The signature is computed over the **raw JSON body** of the request:

```text
Signature = HMAC-SHA256(rawJsonBody, webhook_secret)
```

This is implemented using the [Spatie Laravel Webhook Server](https://github.com/spatie/laravel-webhook-server) `DefaultSigner`:

```php
// Sender side (Zil Money)
hash_hmac('sha256', json_encode($payload), $webhookSecret);
```

### Verification Examples

**PHP:**

```php
$signature = $request->header('Signature');
$rawBody = $request->getContent(); // raw JSON string
$expected = hash_hmac('sha256', $rawBody, $webhookSecret);
$isValid = hash_equals($expected, $signature);

if (!$isValid) {
  http_response_code(401);
  exit('Invalid signature');
}
```

**Node.js (Express):**

```js
const crypto = require('crypto');

// IMPORTANT: use raw body buffer, not parsed JSON
app.post('/webhooks/zilmoney', express.raw({ type: 'application/json' }), (req, res) => {
  const signature = req.headers['signature'];
  const rawBody = req.body.toString();
  const expected = crypto
    .createHmac('sha256', process.env.WEBHOOK_SECRET)
    .update(rawBody)
    .digest('hex');

  const isValid = crypto.timingSafeEqual(
    Buffer.from(expected, 'hex'),
    Buffer.from(signature, 'hex')
  );

  if (!isValid) return res.status(401).send('Invalid signature');
  res.status(200).send('OK');
});
```

**Python (Flask):**

```python
import hmac
import hashlib
from flask import request, abort

@app.route('/webhooks/zilmoney', methods=['POST'])
def webhook():
    signature = request.headers.get('Signature', '')
    raw_body = request.get_data()  # raw bytes, before any parsing
    expected = hmac.new(
        WEBHOOK_SECRET.encode(),
        raw_body,
        hashlib.sha256
    ).hexdigest()

    if not hmac.compare_digest(expected, signature):
        abort(401)

    return 'OK', 200
```

> Always read the raw request body before JSON parsing. Re-serialization can break HMAC validation.

## Retry Behavior

| Property | Value |
| --- | --- |
| Max Attempts | 3 |
| Backoff Strategy | Exponential backoff |
| SSL Verification | Required (HTTPS endpoints only) |

- If all 3 attempts fail, the event status is updated to **FAILED** in your Webhook Log.
- You can manually retry failed events from the **Developer Panel**.
- To protect systems, webhooks can be disabled automatically after excessive failures within a 24-hour window.

## Idempotency

Every webhook delivery has a unique `event.id` (UUID). If your endpoint receives the same `event.id` more than once (for example, retries), process it only once.

Recommended approach:

1. Extract `event.id` from the payload.
2. Check whether this ID was already processed (DB/cache).
3. If already processed, return `200 OK` without re-processing.
4. Otherwise, process the event and store `event.id`.

## Webhook Delivery Status

| Status | Description |
| --- | --- |
| `PENDING` | Queued for delivery |
| `COMPLETED` | Successfully delivered (your endpoint returned 2xx) |
| `FAILED` | All delivery attempts exhausted |

